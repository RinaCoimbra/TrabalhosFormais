options
{
  JDK_VERSION = "1.5";
  static = true; 
  //LOOKAHEAD = 2;
}

PARSER_BEGIN(AWK)

public class AWK {
  public static void main(String args []) throws ParseException  {
    new AWK(System.in);
    System.out.println("Reading from standard input...");
    
    int ok = AWK.Start();
    if (ok == 1) System.out.println("Ok!");
  }
}

PARSER_END(AWK)

SKIP :
{ " " | "\r" | "\t" | "\n" | <["#"](~["\n"])+> }

// -----------------------------------------------
// Tokens
// -----------------------------------------------

TOKEN :
{
  // Special patterns

    < BEGINFUNCAO: "BEGIN" >
  | < ENDFUNCAO:   "END" >

  // Scope 

  | < ESCOPOFUNCAOB: "{"  >
  | < ESCOPOFUNCAOE: "}" >
  | < ESCOPOPARAMB: "(" >
  | < ESCOPOPARAME: ")" >
  | < ESCOPOVECTORB: "[" >
  | < ESCOPOVECTORE: "]" >

  // Control statements

  | < IF: "if" >
  | < ELSE: "else" >
  | < WHILE: "while" >
  | < DO: "do" >
  | < FOR: "for" >
  | < BREAK: "break" >
  | < EXIT: "exit" >
  | < CONTINUE: "continue" >

  // Pontuacoes

  | < PONTOVIRGULA: ";" >
  | < VIRGULA: "," >

  // Expressoes

  | < QUESTION: "?">
  | < COLON: ":">
  | < ASSIGNMENTEQ : "=">
  | < ASSIGNMENTEP : "+=">
  | < ASSIGNMENTEL : "-=">
  | < ASSIGNMENTEM : "*=">
  | < ASSIGNMENTDIV : "/=">
  | < ASSIGNMENTEMOD : "%=">
  | < ASSIGNMENTELEV: "^=">
  | < LOGICALOR: "||">
  | < LOGICALAND: "&&">
  | < OPVETORIN: "in"> // FALTA FAZER
  | < OPLESS: "<">
  | < OPMORE: ">">
  | < OPLESSEQ: "<=">
  | < OPMOREEQ: ">=">
  | < OPDIFF: "!=">
  | < EQEQ: "=="> 
  | < PIPE1 : "|">  // PERGUNTAR COMO FAZ O SPACE DE CONCATENACAO DE STRING
  | < PIPE2 : "|&"> // PERGUNTAR SE EH SOH PRA GETLINE
  | < ADD: "+">
  | < SUB: "-">
  | < MULT: "*">
  | < DIV: "/">
  | < MOD: "%">
  | < EXP: "^">
  | < LOGICALNOT: "!">
  | < INCREMENT: "++">
  | < DECREMENT: "--">
  | < FDREF: "$">

  // Tipos

  | < INT: (["0"-"9"])+>
  | < FLOAT: (["0"-"9"])+("." ((["0"-"9"])+))?>
  | < VAR: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9"])*>
}

// -----------------------------------------------
// Special patterns
// -----------------------------------------------

int Start(): {}
{
  (Begin() | Middle() | End()) <EOF> { return 1; }
}

void Begin():    {}
{    
  (<BEGINFUNCAO> EscopoFuncao())+ [Middle() | End()]
}

void Middle():    {}
{    
  (EscopoFuncao())+ [Begin() | End()]
}

void End():    {}
{    
  (<ENDFUNCAO> EscopoFuncao())+ [Begin() | Middle()]
}

// -----------------------------------------------
// Scope
// -----------------------------------------------

void EscopoParam(): {}
{
  <ESCOPOPARAMB> (Procurador()) <ESCOPOPARAME>
}

void EscopoParamFor(): {}
{
  <ESCOPOPARAMB> (Procurador())* <PONTOVIRGULA> (Procurador())* <PONTOVIRGULA> (Procurador())* <ESCOPOPARAME>
}

void EscopoFuncao(): {}
{
  <ESCOPOFUNCAOB> (If() | DoWhile() | While() | For() | Procurador() | <EXIT>)* <ESCOPOFUNCAOE>
}
 
void EscopoFuncaoWithBreak(): {}
{
  <ESCOPOFUNCAOB> (If() | DoWhile() | While() | For() | Procurador() | <BREAK> | <EXIT> )* <ESCOPOFUNCAOE>
}

void EscopoFuncaoLoop(): {}
{
  <ESCOPOFUNCAOB> (If() | DoWhile() | While() | For() | Procurador() | <CONTINUE> | <BREAK> | <EXIT> )* <ESCOPOFUNCAOE>
}

// -----------------------------------------------
// Actions
// -----------------------------------------------

void Vector(): {}
{
  <ESCOPOVECTORB> (<INT> | <FLOAT>) (<VIRGULA> (<INT> | <FLOAT>))* <ESCOPOVECTORE>
}

void If(): {}
{
  <IF> EscopoParam() (EscopoFuncaoWithBreak() | Procurador()) [<ELSE> (EscopoFuncaoWithBreak()| Procurador())]
}

void DoWhile(): {}
{
  <DO> EscopoFuncaoLoop() <WHILE> EscopoParam()
}

void While(): {}
{
  <WHILE> EscopoParam() EscopoFuncaoLoop()
}

void For(): {}
{
  <FOR> EscopoParamFor() EscopoFuncaoLoop()
}

// -----------------------------------------------
// Expressions
// -----------------------------------------------

void Gambiarra1(): {}
{
  (<INT> | <FLOAT>) [ProcExp()]
}

void Gambiarra2(): {}
{
  <VAR> [Vector()] [(AssignmentOperator() Expression()) | ProcExp()]
}

void Gambiarra3(): {}
{
  [Vector()] [(AssignmentOperator() Expression()) | ProcExp()] 
}

void Procurador(): {}
{
    Gambiarra1() | Gambiarra2()
}

void ProcExp(): {}
{
   (<QUESTION> Expression() <COLON> Expression()) 
  | (<LOGICALOR> Expression()) | (<LOGICALAND> Expression()) | ((< OPLESS>  | < OPMORE>  | < OPLESSEQ>  | < OPMOREEQ>  | < OPDIFF>  | < EQEQ> ) Expression()) | ((<ADD>| <SUB>) Expression()) | ((<MULT>|<DIV>| <MOD>) Expression())|(<EXP> Expression())
}

void AssignmentOperator(): {}
{
  <ASSIGNMENTEQ> | <ASSIGNMENTEP> | <ASSIGNMENTEL> | <ASSIGNMENTEM> | <ASSIGNMENTDIV> | <ASSIGNMENTEMOD> | <ASSIGNMENTELEV>
}

void Expression(): {}
{
  LogicalORExp() [(<QUESTION>  LogicalORExp() <COLON>LogicalORExp())+]
}

void LogicalORExp(): {}
{
  LogicalANDExp() [(<LOGICALOR> LogicalANDExp())+]
}

void LogicalANDExp(): {}
{
  BinaryExp() [(<LOGICALAND> BinaryExp())+]
}

void BinaryExp(): {}
{
   AddSub() [((< OPLESS>  | < OPMORE>  | < OPLESSEQ>  | < OPMOREEQ>  | < OPDIFF>  | < EQEQ> ) AddSub())+]
}

void AddSub(): {}
{
  MultDiv() [ ((<ADD>| <SUB>) MultDiv())+]
}

void MultDiv(): {}
{
  Exponential() [((<MULT>|<DIV>| <MOD>) Exponential())+]
}

// void UnaryExp(): {}
// {
//    [<ADD>| <SUB> | <LOGICALNOT>] Exponential()
// }

void Exponential(): {}
{
  PossibleTokens()[(<EXP> PossibleTokens())+]
}

void PossibleTokens(): {}
{
  (<INCREMENT>|<DECREMENT>) [Prefixos()] (<INT> | (<VAR> [Vector()])| <FLOAT>)
  |  [Prefixos()] (<INT> | (<VAR> [Vector()])| <FLOAT>) [<INCREMENT>|<DECREMENT>]
}

void Prefixos(): {}
{
  (<ADD>|<SUB>|<LOGICALNOT>) [<FDREF>]
}

// void IncDec(): {}
// {
//   ([<INCREMENT> | <DECREMENT>] Parenthesis()) | ( Parenthesis() [<INCREMENT> | <DECREMENT>] )
// }

// void Parenthesis(): {}
// {
//   (<ESCOPOPARAMB> Expression() <ESCOPOPARAME> | <INT> | <VAR> | <FLOAT>)
// }
